// -------------------
//   Unit-Tests mit JUnit 5
// -------------------
repositories { jcenter() }
dependencies {
  // JUnit 5
  testImplementation 'org.springframework.boot:spring-boot-starter-test'
  testImplementation 'org.junit.jupiter:junit-jupiter-api'
  testRuntimeOnly    'org.junit.jupiter:junit-jupiter-engine'

  // Kotlin
  testImplementation 'org.amshove.kluent:kluent:1.49'    // assertions
  testImplementation 'io.mockk:mockk:1.9.3'              // mocking
  testImplementation 'com.ninja-squad:springmockk:1.1.2' // support @MockkBean injection

  // JSON
  testImplementation 'net.javacrumbs.json-unit:json-unit-assertj:2.6.1' // JSON assertions
}

configurations.all {
  exclude group: 'junit', module: 'junit' // entfernt die transitive Abhängigkeit zu JUnit 4, um Konflikte mit JUnit 5 und falsche Importe zu vermeiden
  exclude module: 'mockito-core'          // Mockito is replaced by MockK
}

test {
  useJUnitPlatform()
  testLogging { exceptionFormat = 'full' }
}


// -------------------
//   Integrations-Tests mit JUnit 5
// -------------------
sourceSets {
  integrationTest { sourceSet ->
    [
      "java",
      "groovy",
      "scala",
      "kotlin",
      "resources"
    ].each {
      if (!sourceSet.hasProperty(it)) return
        sourceSet."$it".srcDir file("src/integration-test/${it}")
    }
    compileClasspath += sourceSets.main.output + sourceSets.test.output + configurations.testCompile
    runtimeClasspath += output + compileClasspath + configurations.testRuntime
  }
}

task integrationTest(
    type: Test,
    description: 'Führt die Integrations-Tests aus.',
    group: 'Verification') {
      shouldRunAfter test

      testClassesDirs = sourceSets.integrationTest.output
      classpath = sourceSets.integrationTest.runtimeClasspath

      useJUnitPlatform()
      maxParallelForks = (int) (Runtime.runtime.availableProcessors().intdiv(2) ?: 1) // Test-Klassen parallel ausführen
      testLogging { exceptionFormat = 'full' }

      reports.html.enabled = false // Report-Generierung frisst unnötig CI-Zeit
    }

task allTests ( dependsOn: tasks.withType(Test) )


// -------------------
//   Testabdeckung mit Java Code Coverage
// -------------------
apply plugin: "jacoco"

jacocoTestReport {
  executionData tasks.withType(Test) // Ergebnisse der Unit- und Integrations-Tests zur Testabdeckung heranziehen
  doFirst {
    executionData.from = files(executionData.findAll { it.exists() })
  }
}

jacocoTestCoverageVerification {
  violationRules {
    rule { limit { minimum = 0.5 } } // mindestens 50% Testabdeckung, sonst schlägt Task fehl!
  }
}

// Der Task-Name 'coverage' ist eingängiger als 'jacocoTestReport' ...
task coverage(
    dependsOn: 'jacocoTestReport',
    description: 'Gibt Coverageinformationen aus (Alias für jacocoTestReport).',
    group: 'Verification')
