// -------------------
//   Unit-Tests mit JUnit 5
// -------------------
repositories { maven { url "https://jitpack.io" } }
dependencies {
  // JUnit 5
  testCompile 'org.springframework.boot:spring-boot-starter-test'
  testCompile 'org.junit.jupiter:junit-jupiter-api'
  testRuntime 'org.junit.jupiter:junit-jupiter-engine'

  // security
  testCompile 'org.springframework.security:spring-security-test'

  // persistence
  testRuntime 'com.h2database:h2'                                // schnelle In-Memory-DB für Repository-Unit-Tests
  testCompile 'ru.yandex.qatools.embed:postgresql-embedded:2.10' // erspart externe PostgreSQL-Instanz in Integrations-Tests

  // logging
  testCompile 'net.ttddyy:datasource-proxy:1.4.10'              // erleichtert SQL-Logging
  testCompile 'net.ttddyy:datasource-assert:1.0'

  // serialisation
  testCompile 'com.github.everit-org.json-schema:org.everit.json.schema:1.9.2'
}

configurations.all {
  // entfernt die transitive Abhängigkeit zu JUnit 4, um Konflikte mit JUnit 5 und falsche Importe zu vermeiden
  exclude group: 'junit', module: 'junit'
}

test {
  useJUnitPlatform()
  testLogging { exceptionFormat = 'full' }
}


// -------------------
//   Integrations-Tests mit JUnit 5
// -------------------
sourceSets {
  integrationTest { sourceSet ->
    [
      "java",
      "groovy",
      "scala",
      "kotlin",
      "resources"
    ].each {
      if (!sourceSet.hasProperty(it)) return
        sourceSet."$it".srcDir file("src/integration-test/${it}")
    }
    compileClasspath += sourceSets.main.output + sourceSets.test.output + configurations.testCompile
    runtimeClasspath += output + compileClasspath + configurations.testRuntime
  }
}

task integrationTest(
    type: Test,
    description: 'Führt die Integrations-Tests aus.',
    group: 'Verification') {
      shouldRunAfter test

      testClassesDirs = sourceSets.integrationTest.output
      classpath = sourceSets.integrationTest.runtimeClasspath

      useJUnitPlatform()
      maxParallelForks = (int) (Runtime.runtime.availableProcessors().intdiv(2) ?: 1) // Test-Klassen parallel ausführen
      testLogging { exceptionFormat = 'full' }

      reports.html.enabled = false // Report-Generierung frisst unnötig CI-Zeit
    }

task allTests ( dependsOn: tasks.withType(Test) )


// -------------------
//   Testabdeckung mit Java Code Coverage
// -------------------
apply plugin: "jacoco"

jacoco { toolVersion = "0.8.2" }

jacocoTestReport {
  executionData tasks.withType(Test) // Ergebnisse der Unit- und Integrations-Tests zur Testabdeckung heranziehen
  doFirst {
    executionData = files(executionData.findAll { it.exists() })
  }
}

jacocoTestCoverageVerification {
  violationRules {
    rule { limit { minimum = 0.5 } } // mindestens 50% Testabdeckung, sonst schlägt Task fehl!
  }
}

// Der Task-Name 'coverage' ist eingängiger als 'jacocoTestReport' ...
task coverage(
    dependsOn: 'jacocoTestReport',
    description: 'Gibt Coverageinformationen aus (Alias für jacocoTestReport).',
    group: 'Verification')
